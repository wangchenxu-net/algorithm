冒泡排序  
========

## 原理  

以从小到大排序为例：  

1. 比较相邻的元素。如果前一项比后一项大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。一轮结束后，能够保证这一轮排序后的结果最后项为最大项。
3. 对上一轮排序后的项目，去除第一项后，继续相同的排序操作操作，知道要排序的项目只剩一项。
4. 优化方案：如果一轮排序中，没有交换任一项，则表明每一项都不大于后一项，则此时可以提前结束排序。

## 时间复杂度  

若初始状态是正序的，一轮扫描即可完成排序。所需的比较次数和记录移动次数均达到最小值：
```math
\begin{aligned}
&C_{min}=n-1 \\
&M_{min}=0
\end{aligned}
```

所以，冒泡排序最好的时间复杂度为$$O(n)$$。

若初始状态是反序的，需要进行$$n-1$$趟排序。每趟排序要进行$$n-i(1 \leq i \leq n-1)$$次关键字的比较，且每次比较都必须移动三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：
```math
\begin{aligned}
&C_{max}=\frac{n(n-1)}{2}=O(n^2) \\
&M_{max}=\frac{3n(n-1)}{2}=O(n^2)
\end{aligned}
```

冒泡排序的最坏时间复杂度为$$O(n^2)$$。

综上，因此冒泡排序总的平均时间复杂度为$$O(n^2)$$。

## 空间复杂度  

因为排序自始至终使用的是同一组存储空间，故时间复杂度为$$O(n)$$  
